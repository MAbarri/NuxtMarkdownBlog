import{e as a,k as e,l as t}from"./server.mjs";import{a5 as r,an as s,b4 as n,aw as l}from"../runtime.mjs";import{g as i,C as o}from"../routes/renderer.mjs";function useAsyncData(...c){var d,u,y,f,m,p,_,D;const v="string"==typeof c[c.length-1]?c.pop():void 0;"string"!=typeof c[0]&&c.unshift(v);let[g,h,P={}]=c;if("string"!=typeof g)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof h)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const w=a(),k=h;P.server=null==(d=P.server)||d,P.default=null!=(u=P.default)?u:()=>e.value,P.getCachedData=null!=(y=P.getCachedData)?y:()=>w.isHydrating?w.payload.data[g]:w.static.data[g],P.lazy=null!=(f=P.lazy)&&f,P.immediate=null==(m=P.immediate)||m,P.deep=null!=(p=P.deep)?p:e.deep,P.dedupe=null!=(_=P.dedupe)?_:"cancel";const C=P.getCachedData(g,w),b=null!=C;if(!w._asyncData[g]||!P.immediate){null!=(D=w.payload._errors)[g]||(D[g]=e.errorValue);const a=P.deep?r:s;w._asyncData[g]={data:a(b?C:P.default()),pending:r(!b),error:n(w.payload._errors,g),status:r("idle"),_default:P.default}}const j={...w._asyncData[g]};delete j._default,j.refresh=j.execute=(a={})=>{var r,s;if(w._asyncDataPromises[g]){if("defer"===(s=null!=(r=a.dedupe)?r:P.dedupe)||!1===s)return w._asyncDataPromises[g];w._asyncDataPromises[g].cancelled=!0}if(a._initial||w.isHydrating&&!1!==a._initial){const e=a._initial?C:P.getCachedData(g,w);if(null!=e)return Promise.resolve(e)}j.pending.value=!0,j.status.value="pending";const n=new Promise(((a,e)=>{try{a(k(w))}catch(a){e(a)}})).then((async a=>{if(n.cancelled)return w._asyncDataPromises[g];let t=a;P.transform&&(t=await P.transform(a)),P.pick&&(t=function(a,e){const t={};for(const r of e)t[r]=a[r];return t}(t,P.pick)),w.payload.data[g]=t,j.data.value=t,j.error.value=e.errorValue,j.status.value="success"})).catch((a=>{if(n.cancelled)return w._asyncDataPromises[g];j.error.value=t(a),j.data.value=l(P.default()),j.status.value="error"})).finally((()=>{n.cancelled||(j.pending.value=!1,delete w._asyncDataPromises[g])}));return w._asyncDataPromises[g]=n,w._asyncDataPromises[g]},j.clear=()=>function(a,t){t in a.payload.data&&(a.payload.data[t]=void 0);t in a.payload._errors&&(a.payload._errors[t]=e.errorValue);a._asyncData[t]&&(a._asyncData[t].data.value=void 0,a._asyncData[t].error.value=e.errorValue,a._asyncData[t].pending.value=!1,a._asyncData[t].status.value="idle");t in a._asyncDataPromises&&(a._asyncDataPromises[t]&&(a._asyncDataPromises[t].cancelled=!0),a._asyncDataPromises[t]=void 0)}(w,g);if(!1!==P.server&&w.payload.serverRendered&&P.immediate){const a=j.refresh({_initial:!0});i()?o((()=>a)):w.hook("app:created",(async()=>{await a}))}const x=Promise.resolve(w._asyncDataPromises[g]).then((()=>j));return Object.assign(x,j),x}export{useAsyncData as u};
//# sourceMappingURL=asyncData-OK3DIDI3.mjs.map
